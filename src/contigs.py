# -*- coding: utf-8 -*-

import re
import gzip


# Dictionary maps complementary bases according to IUPAC:
_COMPL_DICT = {
    'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G',
    'R': 'Y', 'Y': 'R', 'S': 'S', 'W': 'W',
    'K': 'M', 'M': 'K', 'B': 'V', 'D': 'H',
    'H': 'D', 'V': 'B', 'U': 'A', 'N': 'N'
}


class Contig:

    def __init__(self, name, length, cov, gc_content, start, rcstart, end, rcend):
        self.name = name
        self.length = length
        self.cov = cov
        self.gc_content = gc_content
        self.start = start
        self.rcstart = rcstart
        self.end = end
        self.rcend = rcend
        self.multplty = None
    # end end __init__

#     def __repr__(self):
#         return '<Contig: {}; {} bp; coverage {}; GC content {}%. multiplicity {};\n\
# {}\n\
# {}\n\
# {}\n\
# {}>\n'.format(self.name, self.length, self.cov, self.gc_content, self.multplty,
#     self.start, self.rcstart, self.end, self.rcend)
#     # end def __repr__

# end class Contig


def get_contig_collection(infpath, maxk):

    contig_collection = list()

    # Pattern that matches ID of seqeunce in FASTA file generated by SPAdes
    spades_patt = r"^NODE_[0-9]+_length_[0-9]+_cov_[0-9,\.]+"

    # Iterate over contigs and form contig_collection dictionary
    for contig_name, contig_seq in _fasta_generator(infpath):

        contig_name = contig_name.strip("_")

        contig_len = len(contig_seq)

        # Retrieve coverage information from SPAdes fasta header
        # `combinator-FQ` can parse SPAdes and A5 assemblies correctly,
        #   and only SPAdes specifies coverage in fasta header.
        # Therefore we'll just write minus character for coverage,
        #   if contigs were assembled not with SPAdes:
        if not re.search(spades_patt, contig_name) is None:
            # Parse fasta header:
            cov = round(float(contig_name.split('_')[5]), 2) # get coverage
            name = 'NODE_' + contig_name.split('_')[1]       # get name in 'NODE_<NUMBER>' format
        else:
            cov = '-'
            name = contig_name # use full header as name
        # end if

        # Calculate GC-content
        gc_content = 0
        for up_base, low_base in zip(('G', 'C', 'S'),('g', 'c', 's')):
            gc_content += contig_seq.count(up_base) + contig_seq.count(low_base)
        # end for
        gc_content = round((gc_content / contig_len * 100), 2)

        contig_collection.append(
            Contig(
                name,
                contig_len,
                cov,
                gc_content,
                contig_seq[:maxk],
                _rc(contig_seq[:maxk]),
                contig_seq[-maxk:],
                _rc(contig_seq[-maxk:])
            )
        )
    # end for

    return contig_collection
# end def get_contig_collection


def assign_multiplty(contig_collection):

    # Coverage of SPAdes's NODE_1 can be zero.
    # In this case we cannot calculate multiplicity of contigs.
    # 'calc_multplty' (calculate multiplicity) will indicate whether we can calculate multiplicity.
    calc_multplty = False
    spades_first_name = 'NODE_1'

    if contig_collection[0].name == spades_first_name:
        # We have SPAdes assembly, and coverage of NODE_1 is non-zero
        calc_multplty = True
        if contig_collection[0].cov < 1e-6:
            print('\n`{}` has zero coverage (less than 1e-6 actually).'\
                .format(contig_collection[0].name))
            print('Multiplicity of contigs cannot be calculated.\n')
            # We have SPAdes assembly, and coverage of NODE_1 is zero
            calc_multplty = False
        # end if
    else:
        # We have non-SPAdes assembly, no coverage provided
        calc_multplty = False
    # end if

    # Calculate multiplicity of contig:
    if calc_multplty:
        for i in range(len(contig_collection)):
            try:
                multiplicity = round(contig_collection[i].cov / contig_collection[0].cov, 1)
            except TypeError:
                contig_collection[i].multplty = 1
            else:
                contig_collection[i].multplty = max(round(multiplicity), 1)
            # end try
        # end if
    else:
        for i in range(len(contig_collection)):
            contig_collection[i].multplty = 1
        # end for
    # end if
# end def assign_multiplty


def _get_compl_base(base):
    # Function returns complement "comrade" of a given base
    return _COMPL_DICT[base]
# end def _get_compl_base


def _rc(seq):
    # Function returns reverse-complement "comrade" of passed DNA sequence
    return ''.join(map( _get_compl_base, reversed(seq) ))
# end def _rc


def _fasta_generator(infpath):

    curr_seq_name = ''
    curr_seq = ''

    if infpath.endswith('.gz'):
        open_func = gzip.open
        fmt_func = lambda x: x.decode('utf-8').strip()
    else:
        open_func = open
        fmt_func = lambda x: x.strip()
    # end if

    with open_func(infpath) as infile:

        eof = False

        # Get the first sequence name
        curr_seq_name = fmt_func(infile.readline())[1:]

        while not eof:
            # Get next line whatever it is
            line = fmt_func(infile.readline())

            if line.startswith('>') or line == '':
                yield curr_seq_name, curr_seq.upper()
                curr_seq_name = line[1:]
                curr_seq = ''
                if line == '':
                    eof = True
                # end if
            else:
                curr_seq += line
            # end if
        # end while
    # end with
# end def _fasta_generator
