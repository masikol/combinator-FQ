# -*- coding: utf-8 -*-

import re
import gzip
from typing import List, Tuple, Dict, Generator, Union, NewType
from typing import Callable, ContextManager, TextIO, BinaryIO


# Dictionary maps complementary bases according to IUPAC:
_COMPL_DICT: Dict[str, str] = {
    'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G',
    'R': 'Y', 'Y': 'R', 'S': 'S', 'W': 'W',
    'K': 'M', 'M': 'K', 'B': 'V', 'D': 'H',
    'H': 'D', 'V': 'B', 'U': 'A', 'N': 'N'
}


class Contig:

    def __init__(self, name: str, length: int,
                 cov: float, gc_content: float,
                 start: str, rcstart: str, end: str, rcend: str) -> None:
        self.name = name
        self.length = length
        self.cov = cov
        self.gc_content = gc_content
        self.start = start
        self.rcstart = rcstart
        self.end = end
        self.rcend = rcend
        self.multplty = None
    # end end __init__

#     def __repr__(self):
#         return '<Contig: {}; {} bp; coverage {}; GC content {}%. multiplicity {};\n\
# {}\n\
# {}\n\
# {}\n\
# {}>\n'.format(self.name, self.length, self.cov, self.gc_content, self.multplty,
#     self.start, self.rcstart, self.end, self.rcend)
#     # end def __repr__

# end class Contig

# Custom types declaration
ContigCollection = NewType('ContigCollection', List[Contig])
ContigIndex = NewType('ContigIndex', int)


def get_contig_collection(infpath: str, maxk: int) -> ContigCollection:

    contig_collection: ContigCollection = list()

    # Pattern that matches ID of seqeunce in FASTA file generated by SPAdes
    spades_patt: str = r'^NODE_[0-9]+_length_[0-9]+_cov_[0-9,\.]+'

    # Iterate over contigs and form contig_collection dictionary
    contig_name: str
    contig_seq:  str
    for contig_name, contig_seq in _fasta_generator(infpath):

        contig_name = contig_name.strip("_")

        contig_len: int = len(contig_seq)

        # Retrieve coverage information from SPAdes fasta header
        # `combinator-FQ` can parse SPAdes and A5 assemblies correctly,
        #   and only SPAdes specifies coverage in fasta header.
        # Therefore we'll just write minus character for coverage,
        #   if contigs were assembled not with SPAdes:
        cov: float
        name: str
        if not re.search(spades_patt, contig_name) is None:
            # Parse fasta header:
            cov = round(float(contig_name.split('_')[5]), 2) # get coverage
            name = 'NODE_' + contig_name.split('_')[1]       # get name in 'NODE_<NUMBER>' format
        else:
            cov = None
            name = contig_name # use full header as name
        # end if

        # Calculate GC-content
        gc_content: float = 0.0

        up_base: str
        low_base: str
        for up_base, low_base in zip(('G', 'C', 'S'),('g', 'c', 's')):
            gc_content += contig_seq.count(up_base) + contig_seq.count(low_base)
        # end for

        gc_content = round((gc_content / contig_len * 100), 2)

        # Append recently created contig to the `contig_collection`
        contig_collection.append(
            Contig(
                name=name,
                length=contig_len,
                cov=cov,
                gc_content=gc_content,
                start=contig_seq[:maxk],
                rcstart=_rc(contig_seq[:maxk]),
                end=contig_seq[-maxk:],
                rcend=_rc(contig_seq[-maxk:])
            )
        )
    # end for

    return contig_collection
# end def get_contig_collection


def assign_multiplty(contig_collection: ContigCollection) -> None:

    # Coverage of SPAdes's NODE_1 can be zero.
    # In this case we cannot calculate multiplicity of contigs.
    # 'calc_multplty' (calculate multiplicity) will indicate whether we can calculate multiplicity.
    calc_multplty: bool = False
    spades_first_name: str = 'NODE_1'

    if contig_collection[0].name == spades_first_name:
        # We have SPAdes assembly, and coverage of NODE_1 is non-zero
        calc_multplty = True
        if contig_collection[0].cov < 1e-6:
            print('\n`{}` has zero coverage (less than 1e-6 actually).'\
                .format(contig_collection[0].name))
            print('Multiplicity of contigs cannot be calculated.\n')
            # We have SPAdes assembly, and coverage of NODE_1 is zero
            calc_multplty = False
        # end if
    else:
        # We have non-SPAdes assembly, no coverage provided
        calc_multplty = False
    # end if

    # Calculate multiplicity of contig:
    i: ContigIndex
    if calc_multplty:
        for i in range(len(contig_collection)):
            try:
                multiplicity: int = contig_collection[i].cov / contig_collection[0].cov
            except TypeError:
                contig_collection[i].multplty = 1
            else:
                contig_collection[i].multplty = max(multiplicity, 1)
            # end try
        # end if
    else:
        for i in range(len(contig_collection)):
            contig_collection[i].multplty = 1
        # end for
    # end if
# end def assign_multiplty


def _get_compl_base(base: str) -> str:
    # Function returns complement "comrade" of a given base
    return _COMPL_DICT[base]
# end def _get_compl_base


def _rc(seq: str) -> str:
    # Function returns reverse-complement "comrade" of passed DNA sequence
    return ''.join(map( _get_compl_base, reversed(seq) ))
# end def _rc


def _fasta_generator(infpath: str) -> Generator[Tuple[str, str], None, None]:

    curr_seq_name: str = ''
    curr_seq: str = ''

    open_func: Callable[[str], ContextManager]
    fmt_func: Callable[[str], str]

    if infpath.endswith('.gz'):
        open_func = gzip.open
        fmt_func = lambda x: x.decode('utf-8').strip()
    else:
        open_func = open
        fmt_func = lambda x: x.strip()
    # end if

    infile: Union[TextIO, BinaryIO]
    with open_func(infpath) as infile:

        eof: bool = False

        # Get the first sequence name
        curr_seq_name = fmt_func(infile.readline())[1:]

        while not eof:
            # Get next line whatever it is
            line: str = fmt_func(infile.readline())

            if line.startswith('>') or line == '':
                yield curr_seq_name, curr_seq.upper()
                curr_seq_name = line[1:]
                curr_seq = ''
                if line == '':
                    eof = True
                # end if
            else:
                curr_seq += line
            # end if
        # end while
    # end with
# end def _fasta_generator
